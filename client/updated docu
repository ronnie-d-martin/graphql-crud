What is GraphQL?
GraphQL is a query language and runtime that lets you interact with your API in a more flexible and efficient way.
Instead of getting too much or too little data, clients can request exactly what they need — nothing more, nothing less.
It also provides a clear, self-explaining structure of your API, making it easier to understand, evolve, and maintain.

Sa REST, kapag nag-request ka ng data, minsan buong object or buong list yung ibinabalik kahit hindi mo naman kailangan lahat.
Sa GraphQL, ikaw mismo ang magsasabi kung anong fields or properties lang ang gusto mong ibalik ng API.

While typical REST APIs require loading from multiple URLs, GraphQL APIs get all the data your app needs in a single request.

Apollo Client and Server
Apollo Client is a JS library that sends requests and fetches data from a GraphQL server.
It manages caching and updates the UI.
Parang waiter na nag papasa ng order from the customer (user) to the kitchen (server).

Apollo Server handles GraphQL queries and mutations.
It connects to data sources think of it as the backend na naghahanda ng tamang data ayon sa order ng customer.

Setup Guide for Apollo Server (Backend)
Initialize Node.js project
npm init --yes
npm pkg set type="module"
Default na pag initialize ng node.js project
This allows us to use import/export instead of require.

Install dependencies
npm install @apollo/server graphql

gawa tayo ng entry point which is si server.js

import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';

What is it?
startStandaloneServer is a helper function provided by Apollo Server that starts a GraphQL server without needing Express or any other web framework.

Isipin niyo siya
Usually sa Node.js, kailangan mo pa mag-setup ng Express app, mag-handle ng body parsing, CORS, etc.
But with startStandaloneServer, lahat ng yan handled na agad para sayo. Less setup, more focus sa GraphQL logic.

const server = new ApolloServer({ /* schema & resolvers here */ });

const { url } = await startStandaloneServer(server, {
  listen: { port: 4000 },
});

console.log(`Server running at: ${url}`);

startStandaloneServer, ini-start niya ang server sa port 4000.
Ang url ay yung address kung saan mo pwedeng i-access yung GraphQL server (usually something like http://localhost:4000/graphql).
Ginamit natin ang await para hintayin na fully ma-start si server, then kinukuha natin yung url gamit ang { url } na shorthand.
Pagkatapos, i-log natin sa terminal para alam natin na gumagana na at kung saan siya naka-host.

GraphQL Core Elements
typeDefs – Schema Definition
Defines the types of data and the structure of queries/mutations.
multi-line strings (like schema definitions or HTML templates), we use backticks ` — this is called a template literal.
Built-in types

const users = [
  { id: "1", name: "John Doe", age: 30, isMarried: true },
  { id: "2", name: "Jane Smith", age: 25, isMarried: false },
  { id: "3", name: "Alice Johnson", age: 28, isMarried: false },
];

backtick = template literals, which allow for string interpolation and multi-line strings
sa GraphQL, scalar types ang mga basic or primitive data types

const typeDefs = `
  type User {
    id: ID
    name: String
    age: Int
    isMarried: Boolean
  }

  type Query {
    getUsers: [User]
  }

  type Mutation {
    createUser(name: String!, age: Int!, isMarried: Boolean!): User
  }
`;

resolvers – Logic Handlers
Resolvers fetch or modify data based on the queries/mutation

const resolvers = {
  Query: {
    getUsers: () => return users,
  },
  Mutation: {
    createUser: (_, args) => {
      const newUser = {
        id: (users.length + 1).toString(),
        ...args
      };
      users.push(newUser);
      return newUser;
    }
  }
};

Sa GraphQL resolver function, may standard na apat na parameters:
(parent, args, context, info)
parent ay yung "pinanggalingan" na field. Kapag nested yung query mo, ito ang connection sa previous result.
Pero kung wala kang kailangan sa parent, pwede mo lang gamitin _ as a placeholder.

Bakit underscore _?
Ginagamit ang _ as a convention para sabihin na:
"Okay lang na nandyan si parent, pero hindi ko siya kailangan gamitin."

Ito yung arguments na galing sa GraphQL query/mutation natin.
Dito natin kinukuha yung id, name, age, isMarried, etc.

Parang "global baggage" siya na pwede mong dalhin sa kahit anong resolver.
Shared object sa buong request lifecycle.
Dito usually nilalagay ang:
Auth info (e.g. JWT token, user info)
DB connection

Mostly ginagamit lang 'to sa mga special cases tulad ng query tracing, schema stitching, or advanced logging.

Client side: 
npm create vite@latest client --template react
npm install @apollo/client graphql

import { ApolloClient, InMemoryCache, ApolloProvider } from "@apollo/client";

const client = new ApolloClient({
  uri: 'http://localhost:4001/', 
  cache: new InMemoryCache(),
});

ApolloClient – Ito yung main object na ginagamit mo para makipag-communicate sa GraphQL server.
Parang messenger siya ng React app mo para mag-query/mutation sa GraphQL backend.

InMemoryCache – Ito naman yung local storage/cache ng Apollo.
Ini-store niya ang data na galing sa server para hindi ka paulit-ulit mag-fetch kapag pareho lang ang data.
i-optimize performance (less server calls)

ApolloProvider lets all your components use GraphQL via the useQuery, useMutation, etc. hooks.

import { gql, useQuery, useMutation } from '@apollo/client';
const GET_USERS = gql`
  query {
    getUsers {
      id
      name
      age
      isMarried
    }
  }
`;

gql - formatter or marker = tag function para sabihin na GraphQL operation ito 

const { data, loading, error, refetch } = useQuery(GET_USERS);
if (loading) return <p>Loading...</p>;
if (error) return <p>Error loading users</p>;

 <div>
      <h2>User list</h2>
      {data.getUsers.map((user) => (
        <div key={user.id}>
          <p>name:{user.name}</p>
          <p>age:{user.age}</p>
          <p>isMarried:{user.isMarried}</p>
        </div>
      ))}
  </div>

const [createUser] = useMutation(CREATE_USER);
const [form, setForm] = useState({ name: '', age: 0, isMarried: false });

   <h2>Create User</h2>
      <input
        placeholder="Name"
        value={form.name}
        onChange={(e) => setForm({ ...form, name: e.target.value })}
      />

      <input
        placeholder="Age"
        value={form.age}
        onChange={(e) => setForm({ ...form, age: parseInt(e.target.value) })}
      />
      <label>
        <input
          type="checkbox"
          checked={form.isMarried}
          onChange={(e) => setForm({ ...form, isMarried: e.target.checked })}
        />
        Married
      </label>

  const handleSubmit = async () => {
    await createUser({ variables: { ...form, age: Number(form.age) } });
    setForm({ name: "", age: 0, isMarried: false });
  };


