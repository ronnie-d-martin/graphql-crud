What is GraphQL?
GraphQL is a query language for APIs and a runtime for handling those queries.
It allows clients to request exactly the data they needâ€”nothing more, nothing less.

sa madaling salita
GraphQL is a way to interact with APIs para makuha natin yung eksaktong data na kailangan natin.
Itâ€™s more flexible and efficient compared to REST.

Sa REST, kapag nag-request ka ng data, minsan buong object or buong list yung ibinabalik kahit hindi mo naman kailangan lahat.
Sa GraphQL, ikaw mismo ang magsasabi kung anong fields or properties lang ang gusto mong ibalik ng API.

ðŸ½ï¸ Analogy Time: Parang Umuorder sa Restaurant
REST API: Nag-order ka ng adobo, pero binigyan ka ng buong menu.

GraphQL: Ikaw mismo ang nagsabi, â€œPahingi po ng adobo at isang serving ng kanin.â€
At yun lang ang ibibigay ng server.

Apollo Client and Server
Apollo Client â€“ The Waiter (Frontend)
Apollo Client is a JS library that sends requests and fetches data from a GraphQL server.

It manages caching and updates the UI.

Parang waiter na nag papasa ng order from the customer (user) to the kitchen (server).

Apollo Server â€“ The Kusinero (Backend)
Apollo Server handles GraphQL queries and mutations.
It connects to data sources (like databases or REST APIs).
Think of it as the backend na naghahanda ng tamang data ayon sa order ng customer.

Setup Guide for Apollo Server (Backend)
Initialize Node.js project
npm init --yes
npm pkg set type="module"
Default na pag initialize ng node.js project
This allows us to use import/export instead of require.

Install dependencies
npm install @apollo/server graphql

gawa tayo ng entry point which is si server.js

import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';

What is it?
startStandaloneServer is a helper function provided by Apollo Server that starts a GraphQL server without needing Express or any other web framework.

Isipin niyo siya
Usually sa Node.js, kailangan mo pa mag-setup ng Express app, mag-handle ng body parsing, CORS, etc.
But with startStandaloneServer, lahat ng yan handled na agad para sayo. Less setup, more focus sa GraphQL logic.

const server = new ApolloServer({ /* schema & resolvers here */ });

const { url } = await startStandaloneServer(server, {
  listen: { port: 4000 },
});

console.log(`Server running at: ${url}`);

startStandaloneServer, ini-start niya ang server sa port 4000.
Ang url ay yung address kung saan mo pwedeng i-access yung GraphQL server (usually something like http://localhost:4000/graphql).
Ginamit natin ang await para hintayin na fully ma-start si server, then kinukuha natin yung url gamit ang { url } na shorthand.
Pagkatapos, i-log natin sa terminal para alam natin na gumagana na at kung saan siya naka-host.

GraphQL Core Elements
typeDefs â€“ Schema Definition
Defines the types of data and the structure of queries/mutations.
multi-line strings (like schema definitions or HTML templates), we use backticks ` â€” this is called a template literal.
Built-in types

const users = [
  { id: "1", name: "John Doe", age: 30, isMarried: true },
  { id: "2", name: "Jane Smith", age: 25, isMarried: false },
  { id: "3", name: "Alice Johnson", age: 28, isMarried: false },
];

backtick = template literals, which allow for string interpolation and multi-line strings
sa GraphQL, scalar types ang mga basic or primitive data types

const typeDefs = `
  type User {
    id: ID
    name: String
    age: Int
    isMarried: Boolean
  }

  type Query {
    getUsers: [User]
  }

  type Mutation {
    createUser(name: String!, age: Int!, isMarried: Boolean!): User
  }
`;

resolvers â€“ Logic Handlers
Resolvers fetch or modify data based on the queries/mutation

const resolvers = {
  Query: {
    getUsers: () => return users,
  },
  Mutation: {
    createUser: (_, args) => {
      const newUser = {
        id: (users.length + 1).toString(),
        ...args
      };
      users.push(newUser);
      return newUser;
    }
  }
};

Sa GraphQL resolver function, may standard na apat na parameters:
(parent, args, context, info)
parent ay yung "pinanggalingan" na field. Kapag nested yung query mo, ito ang connection sa previous result.
Pero kung wala kang kailangan sa parent, pwede mo lang gamitin _ as a placeholder.

Bakit underscore _?
Ginagamit ang _ as a convention para sabihin na:
"Okay lang na nandyan si parent, pero hindi ko siya kailangan gamitin."

Ito yung arguments na galing sa GraphQL query/mutation natin.
Dito natin kinukuha yung id, name, age, isMarried, etc.

Parang "global baggage" siya na pwede mong dalhin sa kahit anong resolver.
Shared object sa buong request lifecycle.
Dito usually nilalagay ang:
Auth info (e.g. JWT token, user info)
DB connection

Mostly ginagamit lang 'to sa mga special cases tulad ng query tracing, schema stitching, or advanced logging.

Client side: 
npm create vite@latest client --template react
npm install @apollo/client graphql

import { ApolloClient, InMemoryCache, ApolloProvider } from "@apollo/client";

const client = new ApolloClient({
  uri: 'http://localhost:4001/', 
  cache: new InMemoryCache(),
});

ApolloClient â€“ Ito yung main object na ginagamit mo para makipag-communicate sa GraphQL server.
Parang messenger siya ng React app mo para mag-query/mutation sa GraphQL backend.

InMemoryCache â€“ Ito naman yung local storage/cache ng Apollo.
Ini-store niya ang data na galing sa server para hindi ka paulit-ulit mag-fetch kapag pareho lang ang data.
i-optimize performance (less server calls)

ApolloProvider lets all your components use GraphQL via the useQuery, useMutation, etc. hooks.

gql - formatter or marker = tag function para sabihin na GraphQL operation ito 
useQuery = pangkuha ng data (GET)
useMutation = pang-send ng data (POST, PUT, DELETE style sa REST)

const { data, loading, error, refetch } = useQuery(GET_USERS);
if (loading) return <p>Loading...</p>;
if (error) return <p>Error loading users</p>;

 <h2>User List</h2>
      {data.getUsers.map((user) => (
        <div key={user.id} style={{ border: '1px solid gray', padding: 10, marginBottom: 10 }}>
          <p><strong>{user.name}</strong></p>
          <p>Age: {user.age}</p>
          <p>Married: {user.isMarried ? 'Yes' : 'No'}</p>
          <button onClick={() => handleEdit(user)}>Edit</button>
          <button onClick={() => handleDelete(user.id)}>Delete</button>
        </div>
      ))}
